<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jupyter Notebook — generated with runcell</title>
    <meta name="description" content="Exported with runcell — convert .ipynb notebooks to HTML or PDF anytime at runcell.dev." />
    <meta name="generator" content="runcell" />
    <style>
        :root {
            --jp-code-font-family: 'SFMono-Regular', Menlo, Consolas, 'Liberation Mono', monospace;
            --jp-content-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            --jp-cell-prompt-width: 64px;
            --jp-input-prompt-color: #307fc1;
            --jp-output-prompt-color: #bf5b3d;
            --jp-cell-input-bg: #f7f7f7;
            --jp-layout-color0: #ffffff;
            --jp-layout-color1: #f7f7f7;
            --jp-border-color1: #e0e0e0;
            --jp-content-font-color0: #000000;
            --jp-content-font-color1: #333333;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: var(--jp-content-font-family);
            font-size: 14px;
            line-height: 1.5;
            color: var(--jp-content-font-color0);
            background-color: var(--jp-layout-color0);
            margin: 0;
            padding: 0;
        }

        .notebook-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Cell structure */
        .cell {
            display: flex;
            flex-direction: row;
            margin-bottom: 12px;
            position: relative;
        }

        .cell-prompt {
            min-width: var(--jp-cell-prompt-width);
            width: var(--jp-cell-prompt-width);
            font-family: var(--jp-code-font-family);
            font-size: 12px;
            padding: 10px 8px 10px 0;
            text-align: right;
            flex-shrink: 0;
            user-select: none;
        }

        .cell-content {
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }

        /* Input prompt styling - Jupyter blue */
        .input-prompt {
            color: var(--jp-input-prompt-color);
            font-weight: bold;
        }

        /* Output prompt styling - Jupyter red/orange */
        .output-prompt {
            color: var(--jp-output-prompt-color);
            font-weight: bold;
        }

        /* Code cell input area */
        .input-area {
            background-color: var(--jp-cell-input-bg);
            border: 1px solid var(--jp-border-color1);
            border-radius: 2px;
            padding: 8px 12px;
            overflow-x: auto;
        }

        .input-area pre {
            margin: 0;
            font-family: var(--jp-code-font-family);
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Output area */
        .output-area {
            margin-top: 0;
        }

        .output-wrapper {
            display: flex;
            flex-direction: row;
            margin-top: 4px;
        }

        .output-content {
            flex: 1;
            min-width: 0;
            padding: 8px 0;
        }

        .output-content pre {
            margin: 0;
            font-family: var(--jp-code-font-family);
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Stream output (stdout/stderr) */
        .output-stream {
            font-family: var(--jp-code-font-family);
            font-size: 13px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .output-stderr {
            background-color: #fdd;
            padding: 8px 12px;
            border-radius: 2px;
        }

        /* Execute result / display data */
        .output-result {
            padding: 4px 0;
        }

        .output-result pre {
            margin: 0;
            font-family: var(--jp-code-font-family);
            font-size: 13px;
        }

        /* Image output */
        .output-image {
            max-width: 100%;
            height: auto;
            display: block;
        }

        /* HTML output (DataFrames, etc.) */
        .output-html {
            overflow-x: auto;
        }

        .output-html table {
            border-collapse: collapse;
            font-size: 13px;
            font-family: var(--jp-content-font-family);
        }

        .output-html table th,
        .output-html table td {
            border: 1px solid #ddd;
            padding: 6px 10px;
            text-align: left;
        }

        .output-html table th {
            background-color: #f5f5f5;
            font-weight: 600;
        }

        .output-html table tr:nth-child(even) {
            background-color: #fafafa;
        }

        /* Error output */
        .output-error {
            background-color: #fff0f0;
            padding: 8px 12px;
            border-radius: 2px;
            font-family: var(--jp-code-font-family);
            font-size: 13px;
            white-space: pre-wrap;
        }

        /* Markdown cell styling */
        .markdown-cell {
            padding: 10px 0;
        }

        .markdown-cell h1 {
            font-size: 2em;
            font-weight: 600;
            margin: 0.67em 0;
            padding-bottom: 0.3em;
            border-bottom: 1px solid var(--jp-border-color1);
        }

        .markdown-cell h2 {
            font-size: 1.5em;
            font-weight: 600;
            margin: 0.83em 0;
            padding-bottom: 0.3em;
            border-bottom: 1px solid var(--jp-border-color1);
        }

        .markdown-cell h3 {
            font-size: 1.25em;
            font-weight: 600;
            margin: 1em 0;
        }

        .markdown-cell h4 {
            font-size: 1em;
            font-weight: 600;
            margin: 1.33em 0;
        }

        .markdown-cell h5 {
            font-size: 0.875em;
            font-weight: 600;
            margin: 1.67em 0;
        }

        .markdown-cell h6 {
            font-size: 0.85em;
            font-weight: 600;
            margin: 2.33em 0;
            color: #6a737d;
        }

        .markdown-cell p {
            margin: 0 0 16px 0;
            line-height: 1.6;
        }

        .markdown-cell code {
            font-family: var(--jp-code-font-family);
            font-size: 85%;
            background-color: rgba(27, 31, 35, 0.05);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        .markdown-cell pre {
            background-color: var(--jp-cell-input-bg);
            border: 1px solid var(--jp-border-color1);
            border-radius: 3px;
            padding: 16px;
            overflow-x: auto;
            font-size: 85%;
            line-height: 1.45;
        }

        .markdown-cell pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            font-size: 100%;
        }

        .markdown-cell blockquote {
            margin: 0 0 16px 0;
            padding: 0 1em;
            color: #6a737d;
            border-left: 4px solid #dfe2e5;
        }

        .markdown-cell ul,
        .markdown-cell ol {
            margin: 0 0 16px 0;
            padding-left: 2em;
        }

        .markdown-cell li {
            margin: 0.25em 0;
        }

        .markdown-cell a {
            color: #0366d6;
            text-decoration: none;
        }

        .markdown-cell a:hover {
            text-decoration: underline;
        }

        .markdown-cell hr {
            border: 0;
            border-top: 1px solid var(--jp-border-color1);
            margin: 24px 0;
        }

        .markdown-cell img {
            max-width: 100%;
            height: auto;
        }

        .markdown-cell table {
            border-collapse: collapse;
            margin: 0 0 16px 0;
        }

        .markdown-cell table th,
        .markdown-cell table td {
            border: 1px solid #dfe2e5;
            padding: 6px 13px;
        }

        .markdown-cell table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }

        .markdown-cell table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }

        /* Raw cell styling */
        .raw-cell {
            background-color: var(--jp-layout-color1);
            border: 1px solid var(--jp-border-color1);
            border-radius: 2px;
            padding: 8px 12px;
            font-family: var(--jp-code-font-family);
            font-size: 13px;
            white-space: pre-wrap;
        }

        /* Empty prompt placeholder */
        .prompt-empty {
            color: transparent;
        }

        .export-footer {
            margin-top: 32px;
            padding-top: 16px;
            border-top: 1px solid var(--jp-border-color1);
            color: #555;
            font-size: 13px;
            text-align: center;
        }

        .export-footer a {
            color: #0366d6;
            text-decoration: none;
        }

        .export-footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="notebook-container">
        <div class="cell cell-markdown">
            <div class="cell-prompt prompt-empty">&nbsp;</div>
            <div class="cell-content">
                <div class="markdown-cell"><h1>Creating a Random Forest Classification Model. </h1><br><br><h2>Bottom Line Up Front: </h2><br><br>The correlation of the features are too low to get more accurate predictions. Currently predicting at 54% at best, might as well be a coin flip to predict who would churn or not.<br><br> We need to collect better data. <br><br><strong><em>Recommendation</strong></em><br><br>I suggest the following: <br>    - Actual Income amount, not just Low/Medium/High. This would have helped narrow down the tax bracket the customers who churn fall in, and tease out a potential reason for churning. <br>    - Monthly spending to see if it is increasing, decreasing or flat.   Might offer insight into predicting who will churn. <br>    - Interaction Quality not just count or resolved. Would answer how the customer felt when it was resolved. Ties in with Monthly Spending, did their spending decrease after an issue was reported, or after it stayed unresolved. <br>    - Check if feedback is positive or negative. <br>    - Consider noSQL to store what the feedback or complaint is, what are they inquiring about to see if customers who churn have the same issue.<br>    - When was the issue reported, when was it resolved. Time to resolution would help me understand better if our customer wait times might be a problem. <br>    - Login dates, not just frequency of login, would be helpful to see if they were logging in a lot at first then suddenly stopped, and maybe we can find out why they stopped by checking the correlation with the above feature recommendations. <br><br>The current dataset captures what customers do but not how they feel about the service. I can calculate Customer Satisfaction Scores from the above features and see how that correlates to churn. <br><br>With the actual income, I can determine what customers earning churn because from the clustering data, it seems like the lower earners, who spend the most are the ones leaving more so that those who login frequently and spend and complain less. See previous report for more detail. <br><br><h2>Algorithm Selection</h2><br>Using Random Forest because while accuracy is important, the task specifies that the model must be interpretable to the stakeholders.<br>Random Forest indicates which features mattered most in the decisions and we can show this to stakeholders that this is why the model made a prediction.<br><br>XG Boost would be the most accurate, but lacks the interpretable aspect, with each decision tree correcting the one before it, tracing the specific prediction becomes tangled. Logistic Regression will be the easiest to explain but will not be as accurate as random forest. <br><br><h2>Implementation:</h2><br>    - I will train the model on 80% of the available Customer_Data_Cleaned set and test it on the remaining 20%.<br><br>    - target (y) is ChurnStatus. <br><br>    - features (x) are all features except CustomerID because it's not important to the analysis, has no bearing whatsoever. <br><br></div>
            </div>
        </div>
        <div class="cell cell-code">
            <div class="cell-prompt input-prompt">In [1]:</div>
            <div class="cell-content">
                <div class="input-area"><pre># install libraries
!python -m pip install --upgrade pip -q
!pip install pandas numpy matplotlib seaborn scikit-learn openpyxl -q
!pip install --upgrade openpyxl -q
!pip install xgboost -q
</pre></div>
            </div>
        </div>
        <div class="cell cell-code">
            <div class="cell-prompt input-prompt">In [2]:</div>
            <div class="cell-content">
                <div class="input-area"><pre># import libraries

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split    
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score</pre></div>
            </div>
        </div>
        <div class="cell cell-code">
            <div class="cell-prompt input-prompt">In [3]:</div>
            <div class="cell-content">
                <div class="input-area"><pre>pd.set_option('display.max_columns', None) # Set option to display all columns
pd.set_option('display.float_format', '{:.2f}'.format) # Set float format to 2 decimal places

# Load the cleaned customer data we previously created, and verify the info and the first few rows
Customer_Data = pd.read_excel('Customer_Data_Cleaned.xlsx')
Customer_Data.info()
Customer_Data.head()</pre></div>
                <div class="output-area">
                    <div class="output-wrapper">
                        <div class="cell-prompt output-prompt"></div>
                        <div class="output-content">
                            <div class="output-stream">&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 1000 entries, 0 to 999
Data columns (total 29 columns):
 #   Column                       Non-Null Count  Dtype  
---  ------                       --------------  -----  
 0   CustomerID                   1000 non-null   int64  
 1   Age                          1000 non-null   float64
 2   isMale                       1000 non-null   int64  
 3   IncomeLevel                  1000 non-null   int64  
 4   ChurnStatus                  1000 non-null   int64  
 5   TotalSpent                   1000 non-null   float64
 6   MinTransaction               1000 non-null   float64
 7   MaxTransaction               1000 non-null   float64
 8   TransactionFrequency         1000 non-null   float64
 9   LoyaltyLength                1000 non-null   float64
 10  InquiryCount                 1000 non-null   float64
 11  InquiryResolved              1000 non-null   float64
 12  InquiryUnresolved            1000 non-null   float64
 13  FeedbackCount                1000 non-null   float64
 14  FeedbackResolved             1000 non-null   float64
 15  FeedbackUnresolved           1000 non-null   float64
 16  ComplaintCount               1000 non-null   float64
 17  ComplaintResolved            1000 non-null   float64
 18  ComplaintUnresolved          1000 non-null   float64
 19  LoginFrequency               1000 non-null   float64
 20  MaritalStatus_Divorced       1000 non-null   int64  
 21  MaritalStatus_Married        1000 non-null   int64  
 22  MaritalStatus_Single         1000 non-null   int64  
 23  MaritalStatus_Widowed        1000 non-null   int64  
 24  ServiceUsage_Mobile App      1000 non-null   int64  
 25  ServiceUsage_Online Banking  1000 non-null   int64  
 26  ServiceUsage_Website         1000 non-null   int64  
 27  TotalUnresolved              1000 non-null   float64
 28  Cluster                      1000 non-null   int64  
dtypes: float64(17), int64(12)
memory usage: 226.7 KB
</div>
                        </div>
                    </div>
                    <div class="output-wrapper">
                        <div class="cell-prompt output-prompt">Out[3]:</div>
                        <div class="output-content">
                            <div class="output-html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>CustomerID</th>
      <th>Age</th>
      <th>isMale</th>
      <th>IncomeLevel</th>
      <th>ChurnStatus</th>
      <th>TotalSpent</th>
      <th>MinTransaction</th>
      <th>MaxTransaction</th>
      <th>TransactionFrequency</th>
      <th>LoyaltyLength</th>
      <th>InquiryCount</th>
      <th>InquiryResolved</th>
      <th>InquiryUnresolved</th>
      <th>FeedbackCount</th>
      <th>FeedbackResolved</th>
      <th>FeedbackUnresolved</th>
      <th>ComplaintCount</th>
      <th>ComplaintResolved</th>
      <th>ComplaintUnresolved</th>
      <th>LoginFrequency</th>
      <th>MaritalStatus_Divorced</th>
      <th>MaritalStatus_Married</th>
      <th>MaritalStatus_Single</th>
      <th>MaritalStatus_Widowed</th>
      <th>ServiceUsage_Mobile App</th>
      <th>ServiceUsage_Online Banking</th>
      <th>ServiceUsage_Website</th>
      <th>TotalUnresolved</th>
      <th>Cluster</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>1.23</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>-1.15</td>
      <td>3.06</td>
      <td>0.25</td>
      <td>-1.56</td>
      <td>-1.89</td>
      <td>1.34</td>
      <td>2.09</td>
      <td>-0.39</td>
      <td>-0.62</td>
      <td>-0.47</td>
      <td>-0.41</td>
      <td>-0.61</td>
      <td>-0.41</td>
      <td>-0.44</td>
      <td>0.58</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>-1.23</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>1.43</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>0.38</td>
      <td>-0.52</td>
      <td>0.07</td>
      <td>0.75</td>
      <td>0.96</td>
      <td>1.34</td>
      <td>2.09</td>
      <td>-0.39</td>
      <td>-0.62</td>
      <td>-0.47</td>
      <td>-0.41</td>
      <td>-0.61</td>
      <td>-0.41</td>
      <td>-0.44</td>
      <td>-1.49</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>-1.23</td>
      <td>8</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>-1.66</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0.59</td>
      <td>-0.55</td>
      <td>0.28</td>
      <td>0.36</td>
      <td>0.28</td>
      <td>1.34</td>
      <td>2.09</td>
      <td>-0.39</td>
      <td>-0.62</td>
      <td>-0.47</td>
      <td>-0.41</td>
      <td>-0.61</td>
      <td>-0.41</td>
      <td>-0.44</td>
      <td>-1.63</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>-1.23</td>
      <td>8</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>-1.46</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>-0.47</td>
      <td>-0.62</td>
      <td>-0.07</td>
      <td>-0.02</td>
      <td>0.10</td>
      <td>3.27</td>
      <td>2.09</td>
      <td>2.41</td>
      <td>-0.62</td>
      <td>-0.47</td>
      <td>-0.41</td>
      <td>-0.61</td>
      <td>-0.41</td>
      <td>-0.44</td>
      <td>-1.70</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1.57</td>
      <td>8</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>-1.46</td>
      <td>1</td>
      <td>2</td>
      <td>0</td>
      <td>0.99</td>
      <td>-0.37</td>
      <td>0.80</td>
      <td>1.13</td>
      <td>0.86</td>
      <td>-0.59</td>
      <td>-0.42</td>
      <td>-0.39</td>
      <td>-0.62</td>
      <td>-0.47</td>
      <td>-0.41</td>
      <td>-0.61</td>
      <td>-0.41</td>
      <td>-0.44</td>
      <td>1.07</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>-1.23</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
</div></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="cell cell-code">
            <div class="cell-prompt input-prompt">In [4]:</div>
            <div class="cell-content">
                <div class="input-area"><pre># Separate features and target variable

X = Customer_Data.drop(columns=['CustomerID', 'ChurnStatus'])
y = Customer_Data['ChurnStatus']

X_train, X_test, y_train, y_test = train_test_split(X, y, 
                                                    test_size=0.2, # 20% for testing
                                                    random_state=42, # makes it reproducible same split every time
                                                    stratify= y # keep churn ratio distributed and balanced in both sets
                                                    )

# # Verify the shape of the splits
# print("X_train shape:", X_train.shape)
# print("X_test shape:", X_test.shape)
# print("y_train shape:", y_train.shape)
# print("y_test shape:", y_test.shape)</pre></div>
            </div>
        </div>
        <div class="cell cell-markdown">
            <div class="cell-prompt prompt-empty">&nbsp;</div>
            <div class="cell-content">
                <div class="markdown-cell"><strong><em>Reasoning:</strong></em><br><br>When creating the for loop to check for hyperparameters, I could have used GridSearchCV but I wanted to evaluate for false alarms as well. <br></div>
            </div>
        </div>
        <div class="cell cell-code">
            <div class="cell-prompt input-prompt">In [ ]:</div>
            <div class="cell-content">
                <div class="input-area"><pre># Create the for loop to tune hyperparameters
best_recall = 0
best_settings = {}

for n_trees in [100, 200, 500]: # select number of trees
    for depth in [5, 10, 20, None]: # select max depth
        for weight in [1, 2, 5, 10]: # select class weight for churners
            for threshold in [0.3, 0.4, 0.5]: # select probability threshold
                model = RandomForestClassifier(n_estimators=n_trees, 
                                                max_depth=depth, 
                                                class_weight={0: 1, 1: weight},
                                                random_state=42) # random state for reproducibility
                model.fit(X_train, y_train)
                probs = model.predict_proba(X_test)[:, 1]
                predictions = (probs &gt;= threshold).astype(int)
                
                caught = confusion_matrix(y_test, predictions)[1, 1]
                false_alarms = confusion_matrix(y_test, predictions)[0, 1]
                recall = caught / 41 # there are 41 actual churners in the test set, caught divided by total actual churners
                
                # Only save if this is the best so far AND false alarms are reasonable
                if recall &gt; best_recall and false_alarms &lt; 80: # stop if more than 80 false alarms, store settings
                    best_recall = recall
                    best_settings = {
                        'trees': n_trees,
                        'depth': depth,
                        'weight': weight,
                        'threshold': threshold,
                        'caught': caught,
                        'false_alarms': false_alarms
                    }

print("Best settings:", best_settings)
print(f"Recall: {best_recall:.2f}")</pre></div>
            </div>
        </div>
        <div class="cell cell-code">
            <div class="cell-prompt input-prompt">In [ ]:</div>
            <div class="cell-content">
                <div class="input-area"><pre>

# Build the RandomForestClassifer class on the best found parameters

model = RandomForestClassifier(n_estimators=500, max_depth = 10, class_weight={0:1, 1:5}, random_state=42).fit(X_train, y_train)
probability = model.predict_proba(X_test)[:, 1]
threshold = 0.30
predictions = (probability &gt;= threshold).astype(int)
accuracy = accuracy_score(y_test, predictions)
class_report = classification_report(y_test, predictions)
conf_matrix = confusion_matrix(y_test, predictions)
print(f'Accuracy: {accuracy:.2f}')
print("Classification Report:\n", class_report)
print("Confusion Matrix:\n", conf_matrix)</pre></div>
            </div>
        </div>
        <div class="cell cell-code">
            <div class="cell-prompt input-prompt">In [ ]:</div>
            <div class="cell-content">
                <div class="input-area"><pre># Check feature importance
importance = pd.DataFrame({
    'Feature': X.columns,
    'Importance': model.feature_importances_
}).sort_values(by='Importance', ascending=False)
display(importance)</pre></div>
            </div>
        </div>
        <div class="cell cell-markdown">
            <div class="cell-prompt prompt-empty">&nbsp;</div>
            <div class="cell-content">
                <div class="markdown-cell"><strong><em>Observations:</strong></em> The features have no real weight. It tracks because of the low correlation across the board.<br><strong><em>Why it Matters:</strong></em> The data collection is insufficient, please see recommendations at the top of the report. <br><br><strong><em>Additional Investigation</strong></em><br>After creating clusters, I add the Cluster to the Data to see if it would increase accuracy. It did but barely. No decrease in the false alarms.<br><br><strong><em>Reasoning: </strong></em><br>Maybe the module can see a pattern between the clusters that would increase accuracy<br></div>
            </div>
        </div>
        <div class="cell cell-code">
            <div class="cell-prompt input-prompt">In [ ]:</div>
            <div class="cell-content">
                <div class="input-area"><pre># Add cluster to features
X_with_cluster = X.copy()
X_with_cluster['Cluster'] = Customer_Data['Cluster']

# Split again with new features
X_train_c, X_test_c, y_train_c, y_test_c = train_test_split(
    X_with_cluster, y, test_size=0.2, random_state=42, stratify=y
)

# Train Random Forest with clusters
model = RandomForestClassifier(n_estimators=500, max_depth=10, 
                                class_weight={0:1, 1:5}, random_state=42)
model.fit(X_train_c, y_train_c)
probs = model.predict_proba(X_test_c)[:, 1]
predictions = (probs &gt;= 0.3).astype(int)

print("WITH clusters:")
print(confusion_matrix(y_test_c, predictions))
print(f"Churners caught: {confusion_matrix(y_test_c, predictions)[1,1]}/41")</pre></div>
            </div>
        </div>
        <div class="cell cell-markdown">
            <div class="cell-prompt prompt-empty">&nbsp;</div>
            <div class="cell-content">
                <div class="markdown-cell">Because of how inaccurate the model using RandomForest is, I decided to check it against XGBoost. The results were similar. Only 2 more caught. </div>
            </div>
        </div>
        <div class="cell cell-code">
            <div class="cell-prompt input-prompt">In [ ]:</div>
            <div class="cell-content">
                <div class="input-area"><pre>from xgboost import XGBClassifier

best_recall = 0
best_settings = {}

for n_trees in [100, 200, 500]:
    for depth in [3, 5, 10]:
        for weight in [5, 10, 15, 20]:
            for threshold in [0.2, 0.3, 0.4, 0.5]:
                model = XGBClassifier(n_estimators=n_trees, 
                                       max_depth=depth, 
                                       scale_pos_weight=weight,
                                       random_state=42)
                model.fit(X_train, y_train)
                probs = model.predict_proba(X_test)[:, 1]
                predictions = (probs &gt;= threshold).astype(int)
                
                caught = confusion_matrix(y_test, predictions)[1, 1]
                false_alarms = confusion_matrix(y_test, predictions)[0, 1]
                recall = caught / 41
                
                if recall &gt; best_recall and false_alarms &lt; 80:
                    best_recall = recall
                    best_settings = {
                        'trees': n_trees,
                        'depth': depth,
                        'weight': weight,
                        'threshold': threshold,
                        'caught': caught,
                        'false_alarms': false_alarms
                    }

print("Best XGBoost settings:", best_settings)
print(f"Recall: {best_recall:.2f}")</pre></div>
            </div>
        </div>
        <div class="cell cell-code">
            <div class="cell-prompt input-prompt">In [ ]:</div>
            <div class="cell-content">
                <div class="input-area"><pre>model = XGBClassifier(n_estimators=200, 
                       max_depth=3, 
                       scale_pos_weight=5,
                       random_state=42)
model.fit(X_train, y_train)
probs = model.predict_proba(X_test)[:, 1]
predictions = (probs &gt;= 0.2).astype(int)
accuracy = accuracy_score(y_test, predictions)
print(f'Accuracy: {accuracy:.2f}')
print(confusion_matrix(y_test, predictions))
print(classification_report(y_test, predictions))</pre></div>
            </div>
        </div>
        <div class="cell cell-code">
            <div class="cell-prompt input-prompt">In [ ]:</div>
            <div class="cell-content">
                <div class="input-area"><pre>model_xgb = XGBClassifier(n_estimators=200, max_depth=3, 
                           scale_pos_weight=5, random_state=42)
model_xgb.fit(X_train_c, y_train_c)
probs = model_xgb.predict_proba(X_test_c)[:, 1]
predictions = (probs &gt;= 0.2).astype(int)

print("XGBoost WITH clusters:")
print(confusion_matrix(y_test_c, predictions))
print(f"Churners caught: {confusion_matrix(y_test_c, predictions)[1,1]}/41")</pre></div>
            </div>
        </div>
    </div>
    <footer class="export-footer">
        Exported with <a href="https://www.runcell.dev/tool/ipynb-to-html">runcell</a> — convert notebooks to HTML or PDF anytime at runcell.dev.
    </footer>
</body>
</html>